import streamlit as st
import subprocess
import os
import threading
import time

st.title("Chat with me!")

# Get the inputs from the text fields with required logs
exe_path = st.text_input("Enter the path to the main.exe binary generated by the steps outlined:",value="..\llama-cpp\main.exe", key="exe_path")
print(f"{exe_path}\n")
if exe_path:
    if os.path.exists(exe_path):
        if os.path.isfile(exe_path):
            print(f"valid file path: {exe_path}")
        else:
            st.error(f"The path {exe_path} is not a file")
    else:
        st.error(f"The path {exe_path} does not exist")
else:
    print("Please enter the file path")

model_path = st.text_input("Enter model file path:", value="..\models\llama-2-7b-chat.Q5_K_M.gguf", key="model_name")
print(f"{model_path}\n")
if model_path:
    if os.path.exists(model_path):
        if os.path.isfile(model_path):
            print(f"valid file path: {model_path}")
        else:
            st.error(f"The path {model_path} is not a file")
    else:
        st.error(f"The path {model_path} does not exist")
else:
    print("Please enter the file path")


num_words = st.text_input("Enter the number of words you'd expect to see in your answer:", value="100", key="num_words")
print(f"{num_words}\n")

question = st.text_input("Enter your question", value="What is AI", key="question")
question = f'"{question}"'
print(f"{question}\n")
num_cores = st.text_input("Enter the number of cores", value="16", key="num_cores")
print(f"{num_cores}\n")
 
gpu_layers = st.text_input("Enter number of GPU layers:", value="999", key="gpu_layers")
print(f"{gpu_layers}\n")

def stdout_typewriter_effect(stdout_container, current_stdout):
    current_char = ""
    for char in current_stdout:
        current_char+=char
        stdout_container.markdown(current_char)
        time.sleep(0.01)

def launch_exe():
    stdout_chunks = []
    stderr_llama_time = []
    
    def append_stdout(pipe, stdout_lines):
        for line in iter(pipe.readline, ''):
            if line:
                print(line.strip())
                stdout_lines.append(line.strip())
        pipe.close()

    def append_stderr(pipe, stderr_lines):
        for line in iter(pipe.readline, ''):
            if line.startswith("llama_print_timings"):
                print(line.strip())
                stderr_lines.append(line.strip())
        pipe.close()

    filter_command = '| findstr "^"'
    # command to run    
    commandparams = exe_path + " " + "-m" + " " + model_path + " " + "-n " + " " + num_words + " " + "--prompt " + " " + question + " " +  "-t " + " " + num_cores + " " + "-e -ngl" + " " + gpu_layers + " " + filter_command
    # logging command for easy debugging
    print(f"{commandparams}")
    try:
        # Use subprocess.Popen() to execute the EXE file with command-line parameters and capture the output in real-time
        result = subprocess.Popen(commandparams, shell=True, stdout=subprocess.PIPE, stderr = subprocess.PIPE, text=True)

        stdout_thread = threading.Thread(target=append_stdout, args=(result.stdout, stdout_chunks))
        stderr_thread = threading.Thread(target=append_stderr, args=(result.stderr, stderr_llama_time))
        stdout_thread.start()
        stderr_thread.start()
        stdout_container = st.empty()
        stderr_container = st.empty()

        # result.poll() returns None only if the subprocess is still running otherwise it returns the return code of subprocess
        # this method is not waiting for subprocess to complete as it only checks for the current status   
        while result.poll() is None and stdout_thread.is_alive or stderr_thread.is_alive():
            # stdout_container.markdown('\n'.join(stdout_lines))
            stdout_typewriter_effect(stdout_container, '\n'.join(stdout_chunks))
            stderr_container.text('\n'.join(stderr_llama_time))
            stdout_thread.join(timeout=0.1)
            stderr_thread.join(timeout=0.1)
            
        stdout_thread.join()
        stderr_thread.join()

    except FileNotFoundError:
        st.error("The specified EXE file does not exist.")
    
if st.button("Generate"):
    with st.spinner("Running....Please wait..üêé"): 
        launch_exe()
